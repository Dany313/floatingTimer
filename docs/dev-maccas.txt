how does 
https://github.com/TorryDo/Floating-Bubble-View
https://github.com/KuhakuPixel/UberAlles/
deal with ViewCompositionStrategy setViewTreeLifecycleOwner recomposer ...

communicate to service through user_prefs
that way can recover, no need to read intent onStartCommand

test what happens if service killed


*** test click past overlay on billingclient IAP buy dialog


why is addView ignoring position of layoutparams???

doitwrong
what if breaks prod.... oh well
just write a lot of test cases

architecture diagram
refactor slowly



billingclient
await after acknowledgePurchase to resume continuation


architecture

FloatingService
  ServiceState
    CountdownState
      OverlayState
    StopwatchState
      OverlayState

  OverlayController
    OverlayViewController x3
      OverlayViewHolder
        LayoutParams
        ComposeView


OverlayController
  FloatingService
    

step 1 service onconfigurationchanged width height

rewrite deriveFullscreenVisibleFlow to listen for isDragging

change layoutparam alpha to 1

StopwatchBubble
CountdownBubble

Bubble(@Composable bubbleContents)

write a bunch of test cases

deriveFullscreenVisibleFlow from showTrash flow combine

there is no need to share the fullscreen overlay
  seperate fullscreen overlay for each timer type

refactor so viewholder holds bubblecontent and state

audit ScreenEz library

use StringResource for notification strings translation
  and notification channel

